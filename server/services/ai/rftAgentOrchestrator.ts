import { getOpenAIClient } from "./aiAnalysis";
import { AGENT_PROMPTS, type AgentRole } from "./multiAgentEvaluator";
import { ragRetrievalService } from "../knowledgebase/ragRetrieval";

// Project context for RFT generation
export interface RftProjectContext {
  projectName: string;
  businessObjective: string;
  scope: string;
  targetSystems: string;
}

// Agent-generated RFT section
export interface AgentRftSection {
  agentRole: AgentRole;
  sectionTitle: string;
  content: string;
  questionsForVendors: string[];
  evaluationCriteria: string[];
}

// Complete RFT generated by all agents
export interface AgentGeneratedRft {
  sections: AgentRftSection[];
  metadata: {
    generatedAt: string;
    projectContext: RftProjectContext;
  };
}

/**
 * Generates an RFT section using a single specialized agent
 * Now enhanced with RAG retrieval of category-specific organizational standards
 */
async function generateAgentRftSection(
  role: AgentRole,
  context: RftProjectContext
): Promise<AgentRftSection> {
  const prompt = AGENT_PROMPTS[role];
  
  if (!prompt.rftCreation) {
    throw new Error(`Agent ${role} does not have RFT creation template configured`);
  }

  // Retrieve category-specific organizational standards for this agent
  let complianceContext = '';
  try {
    const isRAGConfigured = await ragRetrievalService.isConfigured();
    if (isRAGConfigured) {
      // Build enriched retrieval query with role-specific keywords
      const roleKeywords: Record<AgentRole, string> = {
        product: 'product requirements business value user experience stakeholder needs',
        architecture: 'technical architecture system design scalability integration infrastructure',
        engineering: 'API SDK code quality testing observability technical implementation',
        security: 'cybersecurity compliance data protection access control encryption',
        procurement: 'commercial terms pricing SLA contract requirements procurement',
        delivery: 'project management implementation timeline risk mitigation delivery methodology'
      };
      
      const retrievalQuery = `${context.businessObjective} ${context.scope} ${context.targetSystems} ${roleKeywords[role]} requirements standards`;
      
      const ragContextData = await ragRetrievalService.retrieveRelevantContext(
        retrievalQuery,
        { 
          topK: 3,
          category: role, // Each agent gets their own category-specific standards
          sourceType: 'standard' // Only retrieve standards, not proposals
        }
      );
      
      if (ragContextData.chunks.length > 0) {
        complianceContext = ragRetrievalService.formatForAIContext(ragContextData);
        console.log(`   üìö [${role}] Retrieved ${ragContextData.chunks.length} ${role}-specific organizational standards for RFT generation`);
      }
    }
  } catch (error) {
    console.error(`   ‚ùå [${role}] RAG retrieval failed during RFT generation:`, error);
    // Continue without standards context - agent will use general best practices
  }

  // Replace template variables in the user prompt
  let userMessage = prompt.rftCreation
    .replace(/{projectName}/g, context.projectName)
    .replace(/{businessObjective}/g, context.businessObjective)
    .replace(/{scope}/g, context.scope)
    .replace(/{targetSystems}/g, context.targetSystems);

  // Inject organizational standards context if available (matching evaluation format)
  if (complianceContext) {
    userMessage += `\n\n**ORGANIZATION-SPECIFIC COMPLIANCE REQUIREMENTS:**\n\nYou MUST incorporate the following organizational standards and policies into your RFT section. These are mandatory requirements that vendors must address:\n\n${complianceContext}\n\nEnsure your section explicitly references these standards and includes requirements that demonstrate vendor compliance.`;
  }

  try {
    const openai = await getOpenAIClient();
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: prompt.system },
        { role: "user", content: userMessage }
      ],
      response_format: { type: "json_object" },
      temperature: 0.7,
      max_tokens: 4000
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error(`No response from ${role} agent`);
    }

    const parsed = JSON.parse(content);
    
    return {
      agentRole: role,
      sectionTitle: parsed.sectionTitle || `${role.charAt(0).toUpperCase() + role.slice(1)} Requirements`,
      content: parsed.content || "",
      questionsForVendors: Array.isArray(parsed.questionsForVendors) ? parsed.questionsForVendors : [],
      evaluationCriteria: Array.isArray(parsed.evaluationCriteria) ? parsed.evaluationCriteria : []
    };
  } catch (error) {
    console.error(`Error generating RFT section for ${role} agent:`, error);
    
    // Return fallback section if agent fails
    return {
      agentRole: role,
      sectionTitle: `${role.charAt(0).toUpperCase() + role.slice(1)} Requirements`,
      content: `**Note:** This section requires manual completion.\n\nThe ${role} agent encountered an issue during generation. Please manually define the requirements for this domain.`,
      questionsForVendors: [
        `Please provide detailed information about your ${role} capabilities and approach.`
      ],
      evaluationCriteria: [
        `${role.charAt(0).toUpperCase() + role.slice(1)} capabilities and alignment with project requirements`
      ]
    };
  }
}

/**
 * Orchestrates all 6 specialized agents to generate a comprehensive RFT
 * 
 * Each agent contributes their domain-specific section:
 * - Product: Product requirements and IATA standards
 * - Architecture: Technical architecture and scalability requirements
 * - Engineering: API, SDK, code quality, and observability requirements
 * - Security: Security, compliance, and data protection requirements
 * - Procurement: Commercial terms, pricing, SLAs, and contract requirements
 * - Delivery: Delivery methodology, timelines, and risk management requirements
 */
export async function generateAgentDrivenRft(
  context: RftProjectContext
): Promise<AgentGeneratedRft> {
  console.log(`ü§ñ Starting agent-driven RFT generation for: ${context.projectName}`);
  
  const agentRoles: AgentRole[] = [
    "product",
    "architecture",
    "engineering",
    "security",
    "procurement",
    "delivery"
  ];

  // Generate all sections in parallel for speed
  const sectionPromises = agentRoles.map(role => 
    generateAgentRftSection(role, context)
  );

  const sections = await Promise.all(sectionPromises);

  console.log(`‚úÖ Agent-driven RFT generation complete - ${sections.length} sections generated`);

  return {
    sections,
    metadata: {
      generatedAt: new Date().toISOString(),
      projectContext: context
    }
  };
}

/**
 * Compiles agent-generated sections into a single markdown document
 */
export function compileAgentRftToMarkdown(rft: AgentGeneratedRft): string {
  const { sections, metadata } = rft;
  const { projectContext } = metadata;

  let markdown = `# Request for Tender (RFT)\n\n`;
  markdown += `**Project:** ${projectContext.projectName}\n\n`;
  markdown += `**Business Objective:** ${projectContext.businessObjective}\n\n`;
  markdown += `**Scope:** ${projectContext.scope}\n\n`;
  markdown += `**Target Systems:** ${projectContext.targetSystems}\n\n`;
  markdown += `**Generated:** ${new Date(metadata.generatedAt).toLocaleString()}\n\n`;
  markdown += `---\n\n`;

  // Table of Contents
  markdown += `## Table of Contents\n\n`;
  sections.forEach((section, index) => {
    markdown += `${index + 1}. [${section.sectionTitle}](#${section.sectionTitle.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')})\n`;
  });
  markdown += `\n---\n\n`;

  // All sections
  sections.forEach((section) => {
    markdown += `## ${section.sectionTitle}\n\n`;
    markdown += `${section.content}\n\n`;
    
    if (section.questionsForVendors.length > 0) {
      markdown += `### Questions for Vendors\n\n`;
      section.questionsForVendors.forEach((q, i) => {
        markdown += `${i + 1}. ${q}\n`;
      });
      markdown += `\n`;
    }
    
    if (section.evaluationCriteria.length > 0) {
      markdown += `### Evaluation Criteria\n\n`;
      section.evaluationCriteria.forEach((c, i) => {
        markdown += `- ${c}\n`;
      });
      markdown += `\n`;
    }
    
    markdown += `---\n\n`;
  });

  return markdown;
}
